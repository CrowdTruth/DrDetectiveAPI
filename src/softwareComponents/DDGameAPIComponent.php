<?php
namespace CrowdTruth\DDGameapi;

use \Entities\WorkerUnit as WorkerUnit;
use \Entities\Job as Job;
use \Activity as Activity;
use \SoftwareComponent as SoftwareComponent;
use \MongoDate as MongoDate;
use \CrowdAgent as CrowdAgent;


/**
 * Software component for storing in the database jugdements generated by 
 * Dr. Detective Game and which are sent to CrowdTruth via the communication API.
 * 
 * @author carlosm
 */
class DDGameAPIComponent {
	protected $softwareComponent;
	
	/**
	 * Create a DDGameAPIComponent instance.
	 */
	public function __construct() {
		$this->softwareComponent = SoftwareComponent::find('drdetectiveapi');
	}
	
	/**
	 * Store to the database a list of game Judgments.
	 * 
	 * @param $entities List of judgments to be inserted. 
	 * 
	 * @return multitype:string A status array containing the result status information.
	 */
	public function store($entities) {
		$nEnts = count($entities);
		
		$activity = new Activity();
		$activity->softwareAgent_id = $this->softwareComponent->_id;
		$activity->save();
		
		// TODO: questions: with which doctype?
		$docType = 'gamejudgment';
		$seqName = 'entity/gamejudgment';
		
		// The '&' in '&$entity' means we modify the array directly
		foreach ($entities as $key => &$entity) {

			$crowdAgents = [];
			$workerUnits = [];

			$agent = CrowdAgent::where('_id', "crowdagent/biocrowd/" . $entity['user_id'])->first();
			if($agent) {
				// do not delete this on rollback
				if(!array_key_exists($agent->_id, $crowdAgents)) {
					$agent->_existing = true;
					//$crowdAgents[$agent->_id] = $agent;
				}
			} else {
				$agent = new CrowdAgent;
				$agent->_id= "crowdagent/biocrowd/" . $entity['user_id'];
				$agent->softwareAgent_id= 'biocrowd';
				$agent->platformAgentId = $entity['user_id'];
				$agent->save();
				
				$crowdAgents[$agent->_id] = $agent;
			}


			$workerunit = \Entities\Workerunit::where('platformWorkerunitId', $entity['judgment_id'])->first();
			if($workerunit) {
				// do not delete this on rollback
				// TODO: make an extra column in the judgements table that states if it was already sent to crowdtruth or not. 
				if(!array_key_exists($workerunit->_id, $workerUnits)) {
					$workerunit->_existing = true;
					$this->workerUnits[$workerunit->_id] = $workerunit;
					//$workerUnits[$workerunit->_id] = $workerunit;
				}
			} else {
				$workerunit = new Workerunit;
				$workerunit->activity_id = $activity->_id;
				//$workerunit->unit_id = $unitId;
				//$workerunit->acceptTime = $acceptTime;
				//$workerunit->cfChannel = $channel;
				//$workerunit->cfTrust = $trust;
				$workerunit->content = [
					'task_data' => $entity['task_data'],
					'response'  => $entity['response']
				];
				$workerunit->crowdAgent_id = $agent->_id;
				$workerunit->platformWorkerunitId = $entity['judgment_id'];
				$workerunit->flag = $entity['judgment_flag'];
				$workerunit->submitTime = $entity['updated_at'];
				
				//if the game type is CellEx, use gameImageTaggingJudgment. 
				$jugementGameTypeName = $entity['game_type_name'];
				if($jugementGameTypeName = 'CellEx'){
					$workerunit->templateType = 'gameImageTaggingJudgment';
				} else if($jugementGameTypeName = 'VesEx'){
					$workerunit->templateType = 'gameVesicleLocatingJudgment';
				}
				$workerunit->softwareAgent_id = 'biocrowd';

				// Maybe job should be cached if same game_id as previous loop ?
				// TODO: validate empty jobs (although shouldn't happen)
				$job = Job::where('platformJobId', intval($entity['game_id']))
				->where('softwareAgent_id', 'DrDetectiveGamingPlatform')->get()->first();
				$workerunit->job_id = $job->_id;
				$workerunit->project = $job->project;

				$workerUnits[$workerunit->_id] = $workerunit;
				\Queue::push('Queues\SaveWorkerunit', array('workerunit' => serialize($workerunit)));		
				
			}
		}
		
		return [
			'status' => 'ok',
			'nEntities' => count($entities)
		];
	}
}
